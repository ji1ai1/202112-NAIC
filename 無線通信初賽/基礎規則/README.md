# 基础规则

大约0.69。
<br /><br /><br /><br />




## 构建

运行
> 構建.py

可以生成encoder.pth.tar及decoder.pth.tar。
<br /><br /><br /><br />




## 思路

以下按照torch的(样本数, 2, 126, 128)的索引顺序来讨论。

### 分片

每个训练样本在128的维度上均匀切成16段，即每个训练样本分成16片，每片的维度是(2, 126, 8)。这样10000个样本共得到160000片，加上全0.5的片共160001片，作为候选片。将这些候选片保存在模型里。
<br /><br />
对于每个测试样本，在编码阶段按同样的方式分成16片。分别对每片遍历160001个候选片，计算均方误差，选择均方误差最小的候选片，记录下索引。共记录16个索引。每个索引的取值范围是[0, 160001)，可以用18位来储存（2 ** 18 > 160001）；16个索引总共需要288位，其馀位补0。
<br /><br />
在解码阶段，每片根据索引找到相应候选片，然后直接将该片还原为该候选片。例如，记录的索引是[1234, 5678, 91011, ......]，于是将片(:, :, 0:8)还原为第12个候选片，将片(:, :, 0:8)还原为第1234个候选片，将片(:, :, 8:16)还原为第5678个候选片，以此类推。
<br/>

### 压缩

由于该比赛限制模型大小在100M以下，160001片无法保存在模型中。
<br /><br />
注意到原始数据中大部分都是接近0.5的数值，可以以稀疏矩阵的形式保存。将训练数据共(10000×2×126×128)个元素按照到0.5的距离从大到小排序，记录距离最大的n个元素的索引及值（其馀位置直接补0.5）。100M大约可以保存16777216个元素（但实际上保存更少的元素也基本不影响效果）。
<br/>

### 增强

注意到原始数据的值关于0.5对称，因而对于每个候选片，将1 - x也加入到候选片中。这样共320001片，可用19位来保存索引，共需要304位。
